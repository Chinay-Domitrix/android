/*
 * Copyright (C) 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.tools.idea.codenavigation

import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.fileEditor.OpenFileDescriptor
import com.intellij.openapi.project.Project
import com.intellij.pom.Navigatable
import com.intellij.psi.PsiClassOwner
import com.intellij.psi.PsiFile
import com.intellij.psi.search.FilenameIndex
import com.intellij.psi.search.GlobalSearchScope
import org.jetbrains.annotations.VisibleForTesting

/**
 * Navigation source for sections generated by Compose Tracing
 */
class ComposeTracingNavSource(
  @VisibleForTesting private val getFilesByName: (fileName: String) -> List<PsiFile>,
  @VisibleForTesting private val createNavigatable: (files: List<PsiFile>, lineNumber: Int) -> Navigatable?
) : NavSource {
  constructor(project: Project) : this(
    // TODO(b/244437735): find non-deprecated API
    getFilesByName = { fileName -> FilenameIndex.getFilesByName(project, fileName, GlobalSearchScope.allScope(project)).asList() },
    createNavigatable = { files, lineNumber ->
      if (files.isEmpty()) null
      else MultiNavigatable(files.map { OpenFileDescriptor(project, it.virtualFile, lineNumber, -1) })
    }
  )

  private val logger by lazy { Logger.getInstance(ComposeTracingNavSource::class.java) }

  // TODO(b/244437735): use PsiNavSource as a reference to use the PsiManager instead of enumerating files manually
  // TODO(b/244437735): sorting when multiple matches, e.g. prioritise user code when handling multiple matches
  // TODO(b/244437735): add a filter based on library version if multiple versions returned
  override fun lookUp(location: CodeLocation, arch: String?): Navigatable? {
    val fullComposableName = location.fullComposableName ?: return null
    val fileName = location.fileName ?: return null
    val lineNumber = location.lineNumber

    try {
      // Find all files by name
      val fileNameMatch = getFilesByName(fileName)

      // Filter to files where package name is a prefix in fullComposableName
      val packageNamePrefixMatch = fileNameMatch
        .filterIsInstance<PsiClassOwner>()
        .filter { fullComposableName.startsWith("${it.packageName}.") }

      // Filter to files that are long enough to accommodate required lineNumber
      val minLenMatch = packageNamePrefixMatch.filter { it.text.lines().size >= lineNumber }

      // Filter to files with max package name length (fullComposableName includes package name)
      val maxPackageNameLenMatch = with(minLenMatch) {
        if (this.isEmpty()) return null
        val packageNameMaxPrefixLen = this.maxOf { it.packageName.length }
        this.filter { it.packageName.length == packageNameMaxPrefixLen }
      }

      // Return all files that pass the filtering above
      return createNavigatable(maxPackageNameLenMatch, lineNumber)
    }
    catch (e: Exception) {
      logger.warn("Issue while trying to navigate to location: fullComposableName=$fullComposableName, fileName=$fileName, " +
                  "lineNumber=$lineNumber.", e)
      return null
    }
  }

  /** Wraps multiple [Navigatable] objects - e.g. when more than one source location matches search criteria */
  private class MultiNavigatable(private val navigatables: List<Navigatable>) : Navigatable {
    override fun navigate(requestFocus: Boolean) {
      // TODO(b/244437735): notify in UI that multiple files were open
      navigatables.forEach { nav -> nav.navigate(requestFocus) } // open all matching source files
      if (navigatables.size > 1) navigatables.first().navigate(requestFocus) // bring the first source file to front
    }

    override fun canNavigate(): Boolean = navigatables.any { it.canNavigate() }
    override fun canNavigateToSource(): Boolean = navigatables.any { it.canNavigateToSource() }
  }
}